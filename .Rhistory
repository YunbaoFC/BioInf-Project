all(na.omit(genes.info2) == na.omit(genes.info))
###############################################
# 2. Data cleaning and sample alignment
###############################################
## Check for duplicates
ncol(rna.expr.data.N)
length(unique(substr(colnames(rna.expr.data.N), 1,12))) # No duplicates
ncol(rna.expr.data.C)
length(unique(substr(colnames(rna.expr.data.C), 1,12))) # No duplicates
## Convert to data frames
expr.C <- as.data.frame(rna.expr.data.C)
expr.N <- as.data.frame(rna.expr.data.N)
## Shorten patient identifiers
short_names_C <- substr(colnames(expr.C), 1, 12)
short_names_N <- substr(colnames(expr.N), 1, 12)
colnames(expr.C) <- short_names_C
colnames(expr.N) <- short_names_N
## Identify matched samples (patients present in both groups)
matched <- intersect(short_names_N, short_names_C)
length(matched) # 33
setdiff(short_names_N, short_names_C) # 3 normal samples without cancer pair
## Subset to paired samples only
expr.C <- expr.C[, matched, drop = FALSE]
expr.N <- expr.N[, matched, drop = FALSE]
length(intersect(colnames(expr.N), colnames(expr.C)))
setdiff(colnames(expr.N), colnames(expr.C))
dim(expr.C)
dim(expr.N)
## Basic integrity checks
stopifnot(all(rownames(expr.C) == rownames(expr.N)))
stopifnot(!any(is.na(expr.C)), !any(is.na(expr.N)))
stopifnot(!any(is.nan(as.matrix(expr.C))), !any(is.nan(as.matrix(expr.N))))
###############################################
# 3. Normalization using DESeq2
###############################################
## Construct full count matrix
full.data <- cbind(expr.N, expr.C) # Normal first, Cancer after
full.data <- data.frame(full.data)
gene_ids <- rownames(full.data)
## Build condition metadata
condition <- factor(c(
rep("Normal", ncol(expr.N)), # Repeats "Normal" for each normal sample
rep("Tumor",  ncol(expr.C)) # Repeats "Tumor" for each tumor sample
))
metad <- data.frame(condition = condition)
rownames(metad) <- colnames(full.data)
## DESeq2 object
full.data.tidy <- cbind(gene = gene_ids, full.data)
dds <- DESeqDataSetFromMatrix(
countData = full.data.tidy,
colData   = metad,
design    = ~ condition,
tidy      = TRUE
)
## Filter low-count genes
keep <- rowSums(counts(dds) >= 10) >= (0.9 * ncol(expr.C)) # Over 10 counts on 90% of patients
dds <- dds[keep,]
## Normalize counts
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized = TRUE)
any(sum(rowSums(normalized_counts == 0) == ncol(expr.C))) # Verify no gene is 0 on all samples ASK: Should this check across all conjoint samples (66)?
## Split normalized data back into Normal and Tumor
n_norm <- ncol(expr.N)
filtr.expr.N <- as.data.frame(normalized_counts[, 1:n_norm])
filtr.expr.C <- as.data.frame(normalized_counts[, (n_norm + 1):ncol(normalized_counts)])
## Cancerous sample names were added a ".1" because they had the same names as the normal samples
## Remove unwanted ".1" suffixes
colnames(filtr.expr.C) <- substr(colnames(filtr.expr.C), 1, 12)
###############################################################################
# QUESTION 2 : Differentially Expressed Genes (DEGs)
###############################################################################
# 5: Compute fold change (FC) for each gene
# FC = log2(mean expression in cancer / mean expression in normal)
fc <- log2(rowMeans(filtr.expr.C) / rowMeans(filtr.expr.N))
names(fc) <- rownames(filtr.expr.C)
head(fc)
# Compute paired t-test p-values gene-by-gene
# (same patients in tumor vs normal -> paired test)
pval.fc <- sapply(
1:nrow(filtr.expr.C),
function(i) {
t.test(
as.numeric(filtr.expr.C[i, ]),
as.numeric(filtr.expr.N[i, ]),
paired = TRUE
)$p.value
}
)
# Adjust p-values using FDR correction
pval.fc.fdr <- p.adjust(pval.fc, method = "fdr")
# Build table with FC + adjusted p-values
expr.table <- data.frame(cbind(fc, pval.fc.fdr))
expr.table[, 1] <- round(expr.table[, 1], 2)
# Select DEGs using FC and FDR thresholds
deg.genes <- rownames(
expr.table[
abs(expr.table$fc) >= 1.2 & expr.table$pval.fc.fdr <= 0.01,
]
)
# Inspect first 10 DEGs
head(expr.table[deg.genes, ], 10)
# Save DEG table
write.table(expr.table[deg.genes, ], file = "DEG.csv", sep = ";")
# ------------------------------------------------------------------------------
# Volcano plot preparation
# ------------------------------------------------------------------------------
expr.table$diffexpressed <- "/"
expr.table$diffexpressed[
expr.table$fc >= 1.2 & expr.table$pval.fc.fdr <= 0.01
] <- "UP"
expr.table$diffexpressed[
expr.table$fc <= -1.2 & expr.table$pval.fc.fdr <= 0.01
] <- "DOWN"
head(expr.table, 5)
expr.table$diffexpressed <- as.factor(expr.table$diffexpressed)
summary(expr.table$diffexpressed)
# Volcano plot
ggplot(
data = expr.table,
aes(x = fc, y = -log10(pval.fc.fdr), col = diffexpressed)
) +
geom_point() +
xlab("fold change (log2)") +
ylab("-log10 adjusted p-value") +
geom_hline(yintercept = -log10(0.01), col = "red") +
geom_vline(xintercept = 1.2, col = "red") +
geom_vline(xintercept = -1.2, col = "red")
# Extract cancer/normal matrices only for DEGs
filtr.expr.C.DEGs <- filtr.expr.C[rownames(filtr.expr.C) %in% deg.genes, ]
filtr.expr.N.DEGs <- filtr.expr.N[rownames(filtr.expr.N) %in% deg.genes, ]
length(deg.genes)
length(filtr.expr.C.DEGs)
length(filtr.expr.N.DEGs)
###############################################################################
# QUESTION 3 : Gene Co-expression Networks
###############################################################################
# 6: Build adjacency matrices from pairwise correlations
# ------------------------------------------------------
# ===================== CANCER NETWORK ===================== #
# Spearman correlation matrix (with FDR correction)
cor.mat.c <- corr.test(
t(filtr.expr.C.DEGs),
use = "pairwise",
method = "spearman",
adjust = "fdr",
ci = FALSE
)
# Correlation matrix
rho.c <- cor.mat.c$r
diag(rho.c) <- 0  # remove self-correlation
# Corresponding adjusted p-values
qval.c <- cor.mat.c$p
qval.c[lower.tri(qval.c)] <- t(qval.c)[lower.tri(qval.c)]  # symmetrize matrix
# Start adjacency matrix from rho
adj.mat.c <- rho.c
# Apply correlation threshold |rho| â‰¥ 0.7
adj.mat.c <- adj.mat.c * (abs(rho.c) >= 0.7)
# Apply significance threshold (FDR)
adj.mat.c <- adj.mat.c * (qval.c <= 1e-3)
# Binary adjacency matrix
adj.bin.c <- adj.mat.c
adj.bin.c[abs(adj.mat.c) > 0] <- 1
# ===================== NORMAL NETWORK ===================== #
cor.mat.n <- corr.test(
t(filtr.expr.N.DEGs),
use = "pairwise",
method = "spearman",
adjust = "fdr",
ci = FALSE
)
# Build network object
net.c <- network(
adj.mat.c,
matrix.type = "adjacency",
ignore.eval = FALSE,
names.eval = "weights",
directed = FALSE
)
# --- Basic network statistics ---
network.density(net.c)
network.size(net.c)
network.edgecount(net.c)
clustcoeff(adj.mat.c, weighted = FALSE)$CC
# Count edges
sum(adj.mat.c != 0) / 2
sum(adj.mat.c > 0) / 2   # positive correlations
sum(adj.mat.c < 0) / 2   # negative correlations
# Degrees
degree.c <- rowSums(adj.mat.c != 0)
names(degree.c) <- rownames(adj.mat.c)
degree.c <- sort(degree.c, decreasing = TRUE)
head(degree.c, 10)
sum(degree.c == 0)  # number of isolated nodes
# Scale-free check
hist(degree.c)
# --- Identify hubs (top 5% degree) ---
x <- quantile(degree.c[degree.c > 0], 0.95)
x  # threshold value
abline(v = x, col = "red")
hubs.c <- degree.c[degree.c >= x]
hubs.c
summary(expr.table$diffexpressed)
head(expr.table, 5)
# Compute paired t-test p-values gene-by-gene
# (same patients in tumor vs normal -> paired test)
pval.fc <- sapply(
1:nrow(filtr.expr.C),
function(i) {
t.test(
as.numeric(filtr.expr.C[i, ]),
as.numeric(filtr.expr.N[i, ]),
paired = TRUE
)$p.value
}
)
# Adjust p-values using FDR correction
pval.fc.fdr <- p.adjust(pval.fc, method = "fdr")
# Build table with FC + adjusted p-values
expr.table <- data.frame(cbind(fc, pval.fc.fdr))
expr.table[, 1] <- round(expr.table[, 1], 2)
# Select DEGs using FC and FDR thresholds
deg.genes <- rownames(
expr.table[
abs(expr.table$fc) >= 1.2 & expr.table$pval.fc.fdr <= 0.01,
]
)
# Inspect first 10 DEGs
head(expr.table[deg.genes, ], 10)
# Save DEG table
write.table(expr.table[deg.genes, ], file = "DEG.csv", sep = ";")
expr.table$diffexpressed <- "/"
expr.table$diffexpressed[
expr.table$fc >= 1.2 & expr.table$pval.fc.fdr <= 0.01
] <- "UP"
expr.table$diffexpressed[
expr.table$fc <= -1.2 & expr.table$pval.fc.fdr <= 0.01
] <- "DOWN"
head(expr.table, 5)
View(expr.table)
getwd()
setwd("Bureau/Sapienza/BioInf/BioInf-Project") # <- Modify this
getwd() # <- To check you're in the right directory
###############################################################################
# Function to convert from Genes Ensembl -> Genes Symbol
###############################################################################
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl") # Connect to Ensembl
###############################################################################
# Function to convert from Genes Ensembl -> Genes Symbol
###############################################################################
library(useMart)
useMart
###############################################################################
# Function to convert from Genes Ensembl -> Genes Symbol
###############################################################################
library(biomaRt)ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl") # Connect to Ensembl
###############################################################################
# Function to convert from Genes Ensembl -> Genes Symbol
###############################################################################
library(biomaRt)
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl") # Connect to Ensembl
translate_genes <- function(ids, map) {
sapply(ids, function(x) {
sym <- map$hgnc_symbol[map$ensembl_gene_id == x]
if(length(sym) == 0 || sym == "") x else sym
})
}
translate_peptide <- function(ids, map) {
sapply(ids, function(x) {
sym <- map$hgnc_symbol[map$ensembl_peptide_id == x]
if(length(sym) == 0 || sym == "") x else sym
})
}
# Libraries
library(biomaRt)
getwd()
#setwd("Bureau/Sapienza/BioInf/BioInf-Project") # <- Modify this
getwd() # <- To check you're in the right directory
###############################################################################
# Function to convert from Genes Ensembl -> Genes Symbol
###############################################################################
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl") # Connect to Ensembl
translate_genes <- function(ids, map) {
sapply(ids, function(x) {
sym <- map$hgnc_symbol[map$ensembl_gene_id == x]
if(length(sym) == 0 || sym == "") x else sym
})
}
translate_peptide <- function(ids, map) {
sapply(ids, function(x) {
sym <- map$hgnc_symbol[map$ensembl_peptide_id == x]
if(length(sym) == 0 || sym == "") x else sym
})
}
# Read the original file
biogrid <- read.delim("Files/Original_files/BIOGRID-ORGANISM-Homo_sapiens-5.0.252.tab3.txt")
# Filter what we want to get
human_interactions <- subset(
biogrid,
Organism.ID.Interactor.A == 9606 &
Organism.ID.Interactor.B == 9606 &
Experimental.System.Type == "physical"
)
# Only keep the 2 columns Official.Symbol.Interactor A and B
ppi_edges <- human_interactions[, c("Official.Symbol.Interactor.A", "Official.Symbol.Interactor.B")]
head(ppi_edges)
################################################################################
# 4. Clean redundant interactions + self loops + isolate LCC
################################################################################
library(igraph)
library(igraph)
################################################################################
# 5. Clean redundant interactions + self loops + isolate LCC
################################################################################
clean_interactome <- function(df,
colA = 1,
colB = 2,
score_col = NULL) {
# Rename columns
df <- df[, c(colA, colB, score_col), drop = FALSE]
colnames(df)[1:2] <- c("GeneA", "GeneB")
#if (!is.null(score_col)) colnames(df)[3] <- "Score"
# Surp self-loops
df <- df[df$GeneA != df$GeneB, ]
# Supr doubles
df$pair_id <- apply(df[, c("GeneA", "GeneB")], 1, function(x)
paste(sort(x), collapse = "_"))
if (!is.null(score_col)) {
df <- aggregate(Score ~ pair_id + GeneA + GeneB,
data = df,
FUN = max)
} else {
df <- df[!duplicated(df$pair_id), ]
}
df$pair_id <- NULL
# Get graph
g <- graph_from_data_frame(df, directed = FALSE)
# Get only LCC
comp <- components(g)
lcc_id <- which.max(comp$csize)
g_lcc <- induced_subgraph(
g,
vids = V(g)[comp$membership == lcc_id]
)
# Filter Table for LCC
lcc_nodes <- V(g_lcc)$name
df_lcc <- df[
df$GeneA %in% lcc_nodes &
df$GeneB %in% lcc_nodes, ]
return(list(
table_full_clean = df,
table_LCC = df_lcc,
graph_LCC = g_lcc
))
}
biogrid <- clean_interactome(ppi_edges[, c("Official.Symbol.Interactor.A", "Official.Symbol.Interactor.B")])
biogrid_lcc <- biogrid$table_LCC
################################################################################
# 7. Filter wrong alias disease genes
################################################################################
problematic_genes <- c('AGT', 'FAS', 'ARSB', 'AVP', 'DSC2', 'EPO', 'FHL1', 'GLA', 'HGF', 'LAMA3', 'ATP6', 'ATP8', 'COX1', 'ND1', 'ND2', 'ND3', 'ND4', 'ND5', 'ND6', 'TRNG', 'TRNI', 'TRNK', 'TRNL1', 'TRNT', 'TRNV', 'TRNW', 'RAC1', 'RAF1', 'SKI', 'TNNC1', 'AIP', 'CAP2', 'GCOM1', 'RNASEH1')
correct_genes <- c('AGXT', 'FASN', 'SLURP1', 'NLRP3', 'DSC3', 'TIMP1', 'CFH', 'NAT8', 'IL6', 'LAMA4', 'MT-ATP6', 'MT-ATP8', 'MT-CO1', 'MT-ND1', 'MT-ND2', 'MT-ND3', 'MT-ND4', 'MT-ND5', 'MT-ND6', 'MT-TG', ' 	MT-TI', ' 	MT-TK', ' 	MT-TL1', ' 	MT-TT', 'MT-TV', 'MT-TW', 'RNASE1', 'RNASE3', 'HHAT', 'TNNI3', 'AURKAIP1', 'SERPINB8', 'MYZAP', 'RNASEH1P1')
mapping <- setNames(correct_genes, problematic_genes)
corrige_genes <- function(x, mapping) {
idx <- x %in% names(mapping)
x[idx] <- mapping[x[idx]]
x
}
biogrid_lcc$GeneA <- corrige_genes(biogrid_lcc$GeneA, mapping)
biogrid_lcc$GeneB <- corrige_genes(biogrid_lcc$GeneB, mapping)
View(biogrid_lcc)
any(biogrid_lcc$GeneA == biogrid_lcc$GeneB)
biogrid_lcc[biogrid_lcc$GeneA == biogrid_lcc$GeneB, ]
################################################################################
# 2. Translate Huri Genes Ensemble ID into Genes Symbols
################################################################################
huri <- read.delim("Files/Original_files/HI-union.tsv", header = FALSE, stringsAsFactors = FALSE) # Load original file
colnames(huri) <- c("GeneA", "GeneB")
all_genes <- unique(c(huri$GeneA, huri$GeneB)) # Get IDs
# biomaRt request
gene_map <- getBM(
attributes = c("ensembl_gene_id", "hgnc_symbol"),
filters = "ensembl_gene_id",
values = all_genes,
mart = ensembl
)
# Replace in table
huri$GeneA <- translate_genes(huri$GeneA, gene_map)
huri$GeneB <- translate_genes(huri$GeneB, gene_map)
head(huri)
################################################################################
# 4. Filter Reactome
################################################################################
Reactome <- read.delim("Files/Original_files/FIsInGene_04142025_with_annotations.txt")
reactome_genes <- subset(Reactome, select = c(Gene1, Gene2))
################################################################################
# 5. Filter Cardiomyopathy file
################################################################################
Cardiomyopathy <- read.delim("Files/Original_files/diseases_.tsv")
Cardiomyopathy <- subset(Cardiomyopathy, select = c(Associated.genes))
colnames(Cardiomyopathy) <- c("Genes")
head(Cardiomyopathy)
################################################################################
# 6. Filter wrong alias disease genes
################################################################################
problematic_genes <- c('AGT', 'FAS', 'ARSB', 'AVP', 'DSC2', 'EPO', 'FHL1', 'GLA', 'HGF', 'LAMA3', 'ATP6', 'ATP8', 'COX1', 'ND1', 'ND2', 'ND3', 'ND4', 'ND5', 'ND6', 'TRNG', 'TRNI', 'TRNK', 'TRNL1', 'TRNT', 'TRNV', 'TRNW', 'RAC1', 'RAF1', 'SKI', 'TNNC1', 'AIP', 'CAP2', 'GCOM1', 'RNASEH1')
correct_genes <- c('AGXT', 'FASN', 'SLURP1', 'NLRP3', 'DSC3', 'TIMP1', 'CFH', 'NAT8', 'IL6', 'LAMA4', 'MT-ATP6', 'MT-ATP8', 'MT-CO1', 'MT-ND1', 'MT-ND2', 'MT-ND3', 'MT-ND4', 'MT-ND5', 'MT-ND6', 'MT-TG', 'MT-TI', ' 	MT-TK', ' 	MT-TL1', ' 	MT-TT', 'MT-TV', 'MT-TW', 'RNASE1', 'RNASE3', 'HHAT', 'TNNI3', 'AURKAIP1', 'SERPINB8', 'MYZAP', 'RNASEH1P1')
mapping <- setNames(correct_genes, problematic_genes)
corrige_genes <- function(x, mapping) {
idx <- x %in% names(mapping)
x[idx] <- mapping[x[idx]]
x
}
biogrid_lcc$GeneA <- corrige_genes(biogrid_lcc$GeneA, mapping)
biogrid_lcc$GeneB <- corrige_genes(biogrid_lcc$GeneB, mapping)
huri_LCC$GeneA <- corrige_genes(huri_LCC$GeneA, mapping)
huri_LCC$GeneB <- corrige_genes(huri_LCC$GeneB, mapping)
huri_lcc$GeneA <- corrige_genes(huri_LCC$GeneA, mapping)
biogrid$GeneA <- corrige_genes(biogrid_lcc$GeneA, mapping)
biogrid$GeneB <- corrige_genes(biogrid_lcc$GeneB, mapping)
huri$GeneA <- corrige_genes(huri_LCC$GeneA, mapping)
huri$GeneA <- corrige_genes(huri$GeneA, mapping)
huri$GeneB <- corrige_genes(huri$GeneB, mapping)
library(tidyr)
string <- read.delim("Files/Cardiomyopathy.txt")
string$GeneA <- corrige_genes(string$GeneA, mapping)
string$GeneB <- corrige_genes(string$GeneB, mapping)
reactome_lcc$GeneA <- corrige_genes(reactome_lcc$GeneA, mapping)
reactome_lcc$GeneB <- corrige_genes(reactome_lcc$GeneB, mapping)
reactome$GeneA <- corrige_genes(reactome$GeneA, mapping)
reactome$GeneB <- corrige_genes(reactome$GeneB, mapping)
reactome$GeneA <- corrige_genes(reactome_genes$GeneA, mapping)
reactome$GeneB <- corrige_genes(reactome_genes$GeneB, mapping)
String_sep <- string
String_sep$GeneA <- corrige_genes(String_sep$GeneA, mapping)
String_sep$GeneB <- corrige_genes(String_sep$GeneB, mapping)
reactome_genes$GeneA <- corrige_genes(reactome_genes$GeneA, mapping)
reactome_genes$GeneB <- corrige_genes(reactome_genes$GeneB, mapping)
Cardiomyopathy$Genes <- corrige_genes(Cardiomyopathy$Genes, mapping)
################################################################################
# 7. Clean redundant interactions + self loops + isolate LCC
################################################################################
clean_interactome <- function(df,
colA = 1,
colB = 2,
score_col = NULL) {
# Rename columns
df <- df[, c(colA, colB, score_col), drop = FALSE]
colnames(df)[1:2] <- c("GeneA", "GeneB")
#if (!is.null(score_col)) colnames(df)[3] <- "Score"
# Surp self-loops
df <- df[df$GeneA != df$GeneB, ]
# Supr doubles
df$pair_id <- apply(df[, c("GeneA", "GeneB")], 1, function(x)
paste(sort(x), collapse = "_"))
if (!is.null(score_col)) {
df <- aggregate(Score ~ pair_id + GeneA + GeneB,
data = df,
FUN = max)
} else {
df <- df[!duplicated(df$pair_id), ]
}
df$pair_id <- NULL
# Get graph
g <- graph_from_data_frame(df, directed = FALSE)
# Get only LCC
comp <- components(g)
lcc_id <- which.max(comp$csize)
g_lcc <- induced_subgraph(
g,
vids = V(g)[comp$membership == lcc_id]
)
# Filter Table for LCC
lcc_nodes <- V(g_lcc)$name
df_lcc <- df[
df$GeneA %in% lcc_nodes &
df$GeneB %in% lcc_nodes, ]
return(list(
table_full_clean = df,
table_LCC = df_lcc,
graph_LCC = g_lcc
))
}
huri <- clean_interactome(huri[, c("GeneA", "GeneB")])
biogrid <- clean_interactome(ppi_edges[, c("Official.Symbol.Interactor.A", "Official.Symbol.Interactor.B")])
reactome <- clean_interactome(reactome_genes[, c("Gene1", "Gene2")])
string <- clean_interactome(String_sep[, c("ProteinA", "ProteinB", "Score")])
write.table(reactome$table_LCC, "Files/Reactome.txt", sep = "\t", row.names = FALSE, quote = FALSE)
head(String_sep)
String_sep <- read.delim("Files/String.txt")
head(String_sep)
################################################################################
# 6. Filter wrong alias disease genes
################################################################################
problematic_genes <- c('AGT', 'FAS', 'ARSB', 'AVP', 'DSC2', 'EPO', 'FHL1', 'GLA', 'HGF', 'LAMA3', 'ATP6', 'ATP8', 'COX1', 'ND1', 'ND2', 'ND3', 'ND4', 'ND5', 'ND6', 'TRNG', 'TRNI', 'TRNK', 'TRNL1', 'TRNT', 'TRNV', 'TRNW', 'RAC1', 'RAF1', 'SKI', 'TNNC1', 'AIP', 'CAP2', 'GCOM1', 'RNASEH1')
correct_genes <- c('AGXT', 'FASN', 'SLURP1', 'NLRP3', 'DSC3', 'TIMP1', 'CFH', 'NAT8', 'IL6', 'LAMA4', 'MT-ATP6', 'MT-ATP8', 'MT-CO1', 'MT-ND1', 'MT-ND2', 'MT-ND3', 'MT-ND4', 'MT-ND5', 'MT-ND6', 'MT-TG', 'MT-TI', ' 	MT-TK', ' 	MT-TL1', ' 	MT-TT', 'MT-TV', 'MT-TW', 'RNASE1', 'RNASE3', 'HHAT', 'TNNI3', 'AURKAIP1', 'SERPINB8', 'MYZAP', 'RNASEH1P1')
mapping <- setNames(correct_genes, problematic_genes)
corrige_genes <- function(x, mapping) {
idx <- x %in% names(mapping)
x[idx] <- mapping[x[idx]]
x
}
String_sep$GeneA <- corrige_genes(String_sep$GeneA, mapping)
String_sep$GeneB <- corrige_genes(String_sep$GeneB, mapping)
string <- clean_interactome(String_sep[, c("GeneA", "GeneB")])
################################################################################
# 8. Write new files
################################################################################
write.table(biogrid$table_LCC,file = "Files/Biogrid.txt",sep = "\t",row.names = FALSE,quote = FALSE)
write.table(huri$table_LCC, "Files/Huri.txt", sep = "\t", row.names = FALSE, quote = FALSE)
write.table(string$table_LCC, "Files/String.txt", sep = "\t", row.names = FALSE, quote = FALSE)
write.table(reactome$table_LCC, "Files/Reactome.txt", sep = "\t", row.names = FALSE, quote = FALSE)
write.table(Cardiomyopathy,file = "Files/Cardiomyopathy.txt",sep = "\t",row.names = FALSE,quote = FALSE)
